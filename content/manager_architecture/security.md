---
layout: bt_wiki
title: Security
category: Manager Architecture
draft: false
weight: 900
---


Security, in the context of a Cloudify Manager, means securing communication with the Cloudify Manager and controlling who
has permissions to use it to execute various operations.
<br>Secured communication is achieved using SSL, which allows clients to validate the authenticity of the Cloudify Manager,
and to ensure that the data sent to and from it is encrypted.<br>
Controlling access to Cloudify Manager, and permissions to perform actions, is implemented via Flask-Security, to support user authentication and authorization.

Cloudify Manager is secured by default. It cannot be bootstrapped in a non-secured way.

<br>Details about Cloudify's SSL and Access Control implementation and configuration are provided below.

Cloudify security for client access focuses on the REST service, which this is the first and only access point of clients to 
Cloudify Manager. All requests to Cloudify Manager are authenticated and authorized before reaching their endpoint.
<br>
For example, when a Web-interface user attempts to upload a new blueprint, a request is sent to the REST service's
*/blueprints* endpoint through port 80 / 443. The request only reaches the endpoint if the user is logged in and is authorized to upload
blueprints. Similarly, a user who executes the CLI command `cfy deployments list` triggers a request to execute `GET` on
*/deployments* that is only be successful if it includes valid credentials that identify an authorized
user.
<br>Requests generated by other HTTP clients (e.g. curl) must also include valid credentials. Required credentials are a user name and password, or a Cloudify-generated token, and a tenant name. If credentials are missing, invalid, or represent an unauthorized user, the request fails with a "401: Unauthorized User"
error.

{{% gsNote title="Note" %}}
The */version* endpoint is not a secured resource, and is therefore open to all users.
{{% /gsNote %}}

### Authorization
A combination of roles, permissions and multi-tenancy provides the framework for authorization and resource isolation.

#### Roles & Permissions
Cloudify includes built-in user roles with which users are associated:<br>
* `Administrator`
* `User`
* `Suspended`

Each role has different permissions, ensuring a role-based access control operation. For example, users with the `user` role cannot perform Cloudify administration operations such as snapshot management, a `suspended` user cannot perform operations, and so on.

#### Isolation
Cloudify supports the concept of users, user groups, and tenants. These elements can be either defined locally in Cloudify, or taken from an external user management system (LDAP integration is native). In the latter case, passwords are not stored in Cloudify, authentication is performed via LDAP and a token is generated and used for the user session.<br>
A user can be associated with one or more groups, and one or more tenants.<br>
A group can be associated with one or more tenant.

A user who is authenticated to Cloudify may only access resources that belong to that user’s tenants. Resource isolation is implemented for blueprints, artifacts, deployments, nodes, logs, events, and plugins.

An additional layer of permission control is implemented on resources, allowing private resource configuration. A resource that is created as private is only visible to the user who created that resource, and not to other users within the tenant. The exception is a user with an `administrator` role, who has full access to all system resources.

All REST APIs, except admin APIs and the version API, require a tenant, and an operation is associated with the specified tenant. In the case of Read operations, only information about the specified tenant is returned. In the case of Write operations, the resource is added to the specified tenant.

Admin APIs are provided for the following resources (and are available only to `administrator` users):

* Tenant management (CRUD)
* User management (CRUD)
* User group management (CRUD)
* Snapshot management (CRD)
* Cluster management (configuration of manager HA)
* Maintenance mode activation/de-activation
* Upgrade/rollback commands 

{{% gsNote title="Future Plans" %}}
RabbitMQ isolation is achieved through the use of virtual hosts and the association between hosts and users, which enables authorization at the queue/exchange level and results in isolation of queues between tenants. In this configuration it is impossible for a host VM from tenant A to access/request operations on host VMs that belong to tenant B.<br> 
*This feature is planned for version 4.1.*
{{% /gsNote %}}

### Encryption
#### Scope
Communication from the outside world to Cloudify Manager and its SSL/TLS configuration is the user’s responsibility (CA/host verification, etc.), where the endpoints include the UI and REST API.
Communication between Cloudify agents and Cloudify Manager (and within Cloudify Manager) is the responsibility of Cloudify, and is determined by Cloudify. Cloudify generates the necessary certificates for internal communication.
Credentials do not appear in log files (cloud/RabbitMQ/Cloudify).

#### Communication Channels
To simplify the architecture, the number of internal communication channels is reduced.<br>
* Agents poll for task execution requests by connecting to the RabbitMQ server on the manager. 
* Access to the file server or REST API occurs through a secured port (authn, authz, encryption) that is controlled by Cloudify.
* Accessing a REST API internally is not be handled by Cloudify. If a user enables enabled SSL/auth over port 80 and chooses to use a REST client, either from a plugin or a script, they must configure it correctly.

#### Certificate Propagation
Cloudify creates private/public keys for the transport that is used by both RabbitMQ and file server access. The certificate is used to identify Cloudify Manager, there are no agent-host certificates. The manager certificate is propagated automatically to the agent host as part of the agent installation.<br>

Certificate propagation depends on agent installation, as described below:<br>
* **SSH/WinRM:** On agent installation, Cloudify uploads the certificate to the VM running the agent. Note that WinRM is not encrypted in Cloudify and might pose a security risk.
* **Cloud-init/Userdata:** Injects the certificate as part of the agent installation script injected to the VM.
* **Provided:** The user places the certificate in a static location on the VM.




Non-repudiation

SSL is enabled for agent-manager communication. In addition, using SSL for client-server communication is possible and ensures: <br>
* **Privacy:** All communications between the client the server are encrypted.
* ** Trust:** When a connection is established, Cloudify Manager presents a signed certificate to the client. The client can use that certificate to validate the authenticity of the manager. 

Requests to Cloudify Manager can be addressed to its public or private IP address.
By default, internal requests (i.e. requests sent from Cloudify Manager itself, or from agent hosts) are sent to the Cloudify Manager private IP address. External requests (i.e. requests originating from other, external clients) must be sent to the Cloudify Manager public address.

Each of the server’s IP addresses has a different SSL key pair, created with the matching address as its CN value. Sending a request to the wrong address could therefore fail, since the manager might present the wrong SSL certificate to the client.

Misc
Starting 4.0, all service required by Cloudify will run under the Cloudify (and not root) user in the manager VM. The only exception is the parent process of Nginx which runs as root in order to enable usage of port 80. It is not recommended to change this behavior.
A secret store is implemented inside the Cloudify DB (Postgres), providing an encrypted, tenant-wide variable store:
Through usage of the secret store a user can ensure all secrets (such as credentials to IaaS environments, passwords, etc) are kept in an encrypted manner, and adhere to isolation requirements between different tenants.
Secrets can be added to the store by a set function, and retrieved (encrypted) via get.
Export as environment variables enables agents to use secrets
Plugins can get and unencrypt secrets, to leverage those when communicating with IaaS environments
Managers should be secured via SSL to ensure secrets are not passed on an unencrypted communication channel
Usage of Postgres ensure replication of secrets across all managers within a cluster as part of HA





### Security Configuration
Security configuration is implemented in the Cloudify blueprint. The default settings are specified in the [manager-types.yaml](https://github.com/cloudify-cosmo/cloudify-manager-blueprints/blob/3.3/types/manager-types.yaml#L45),
in the following path:
{{< gsHighlight  yaml >}}
node_types:
  ...
  cloudify.nodes.MyCloudifyManager:
    ...
    properties:
      ...
      security:
{{< /gsHighlight >}}

The default configuration can be overridden by specific Cloudify blueprint YAML files. Each setting is described in
detail in the following sections.

<br>
#### Enabling or Disabling Security
The first security setting is:

{{< gsHighlight  yaml  >}}
enabled: { get_input: security_enabled }
{{< /gsHighlight >}}

Security is enabled or disabled according to the input value `security_enabled`. To activate security, set
the input value `security_enabled` to `true`. <br>

{{% gsNote title="Warning" %}}
If `security_enabled` is set to `false`, all other security settings are ignored, including SSL.
{{% /gsNote %}}

<br>
# SSL

SSL is enabled for communication between agents and Cloudify Manager. In addition, using SSL for client-server communication is possible, and ensures: <br>
* **Privacy:** All communications between the client and the server are encrypted. <br>
* **Trust:** When a connection is established, Cloudify Manager presents a signed certificate to the
client. The client can use that certificate to validate the authenticity of Cloudify Manager. <br>

<br><br>
Requests to Cloudify Manager can be addressed to its public or private IP address.<br>
By default, internal requests (i.e. requests sent from Cloudify Manager or from agent hosts) are sent to the
manager's private IP address, while external requests (i.e. requests originating from other, external clients) should
be sent to the manager's public address.

{{% gsNote %}}
Each of the server's IP addresses has a different SSL key pair, created with the address that matches its CN value.
Sending a requests to the wrong address could therefore fail, since the manager might present the wrong SSL certificate
to the client.
{{% /gsNote %}}

Depending on your environment, set the routing of internal and external requests to the preferred address
(see `rest_host_internal_endpoint_type` and `rest_host_external_endpoint_type` below).

{{% gsInfo title="Client-side certificates are not used"%}} {{% /gsInfo %}}

<br>
### Configuring SSL
1. Enabling SSL<br>
  SSL is enabled and disabled according to the input field `ssl_enabled`. By default, SSL is disabled. To
  enable SSL, set `ssl_enabled: true`. When enabled, every request to Cloudify Manager must be sent over HTTPS to port 443.
  <br><br>
2. Setting internal and external request routing<br>
  By default, internal requests are sent to the Cloudify Manager private IP address. To override this behavior, set
  `rest_host_internal_endpoint_type: public_ip`.
  External requests are expected to be sent to the Cloudify Manager public address. To override this, set
  `rest_host_external_endpoint_type: private_ip`
3. Required Files<br>
  Upon bootstrap, the key pairs matching the internal and external addresses can be provided, by placing them in the
  manager blueprint's directory (on the client machine), under *"/resources/ssl"* :<br>
   * external_rest_host.crt - the certificate presented to requests that address the manager's public IP<br>
   * external_rest_host.key - the matching key <br>
   * internal_rest_host.crt - the certificate presented to requests that address the manager's private IP<br>
   * internal_rest_host.key - the matching key <br>
  If the key pairs are not provided at bootstrap, self-signed certificates and matching keys will be created during
  bootstrap.

{{% gsNote title="Provided SSL certificate" %}}
  An example of an SSL certificate is included with cloudify's manager blueprints under */resources/ssl"*. The example certificate should not be used when bootstrapping a manager as it may pose a security threat.
{{% /gsNote %}}

{{% gsInfo title="Creating a valid certificate"%}}
  The SSL verification process requires the common name in the certificate to match the requested URL. Since all
  requests to the manager use the manager's IP address, it is required that the certificate be created with that IP
  address as its common name.
{{% /gsInfo %}}

<br>
# Manager Access Control

Cloudify's Access Control is comprised of two steps - authentication and authorization. While authentication is
mandatory when accessing a secured resource, authorization is optional. The sections below detail the access control
components and their configuration.

<br>
## Authentication

### Userstore Drivers
While Cloudify does not manage user accounts, some authentication methods may require access to an external userstore -
a repository of users - from which a user object is retrieved. In most cases, the userstore is a directory
(e.g. ActiveDirectory) or a database. *Userstore Drivers* are classes that implement access to different userstore types.
Cloudify assumes there is (at most) one userstore from which all users can be loaded.

#### Userstore driver configuration
Under "userstore_driver" a single userstore is set. Below is the default userstore configuration, set in
manager-types.yaml:
{{< gsHighlight  yaml  >}}
  security:
    ...
    userstore_driver:
      implementation: flask_securest.userstores.simple:SimpleUserstore
      properties:
        userstore:
          users:
            - username: { get_input: admin_username }
              password: { get_input: admin_password }
              groups:
                - cfy_admins
          groups:
            - name: cfy_admins
              roles:
                - administrator
{{< /gsHighlight >}}

The userstore_driver configuration includes two keys:

* implementation - the fully qualified name of the module implementing a userstore driver, followed by ":" and the
class name. <br>In the above configuration, `flask_securest.userstores.simple` is the module, and `SimpleUserstore` is the
class name. <br>
* properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method.

#### Simple Userstore driver
The default configuration uses [Flask-SecuREST's simple userstore]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/userstores/simple.py).
In this implementation, the userstore is a simple data-structure defined in the manager blueprint and instantiated during
bootstrap.

**Configuring the Simple Userstore:**

* implementation - The implementation field should point to `flask_securest.userstores.simple:SimpleUserstore`.
* properties - Holds the actual userstore to be used as demonstrated in the example above.
{{% gsNote title="Note" %}}
The configuration above describes a userstore having a single user, that accepts its username and password from
input values (`admin_username` and `admin_password` respectively). This implementation is good for demonstration
purposes. Nevertheless, Configuring a "real" userstore driver (e.g. ActiveDirectory) is just as easy, as explained later.
{{% /gsNote %}}

#### File Userstore driver {{% tag %}} 3.3.1 FEATURE {{% /tag %}}
The file based userstore provides the ability to define users and groups in an external file located on the manager host.
This file can later be edited and will be reloaded by the Flask-SecuREST framework upon modification. A sample userstore file can be found [here]
(https://github.com/cloudify-cosmo/cloudify-manager-blueprints/blob/master/resources/rest/userstore.yaml).

**Configuring the File Userstore:**

* implementation - The implementation field should point to `flask_securest.userstores.file_userstore:FileUserstore`.
* properties - `userstore_file_path` specifies the file's remote target path.
{{% gsNote title="Important note" %}}
Users running Cloudify version **3.3.0** are required to modify the
[rest-service's create.sh](https://github.com/cloudify-cosmo/cloudify-manager-blueprints/blob/3.3-build/components/restservice/scripts/create.sh#L92) to also copy the userstore file on bootstrap
similarly to the `roles_config.yaml` file.
{{% /gsNote %}}

<br>
### Authentication Providers
Authenticating a request can be done in different ways - matching passwords, binding to a directory service or
delegating the login to an external service (oAuth). Each implementation of an authentication methods is called an
*Authentication Provider* (AKA *Authenticator*). When processing a request, Cloudify calls the registered authenticators
(one or more) in the order of definition in the manager-blueprint. If the first authenticator fails to authenticate the
request - the second will be used, and so on, until successful.<br>
If none of the authenticators succeeded, a "401: Unauthorized User" error is returned.

<br>
#### Authentication providers configuration
Under "authentication_providers" is a list of all authenticators in the order they should be executed. At least one
authentication provider must be set. The default configuration set in manager-types.yaml uses two authenticators -
"password" and "token":
{{< gsHighlight  yaml  >}}
  security:
    ...
    authentication_providers:
      - name: password
        implementation: flask_securest.authentication_providers.password:PasswordAuthenticator
        properties:
          password_hash: plaintext
      - name: token
        implementation: flask_securest.authentication_providers.token:TokenAuthenticator
        properties:
          secret_key: my_secret
{{< /gsHighlight >}}

Each Authentication Provider configuration includes these keys:

* name - a unique name describing this authenticator. This name will appear in logs so it should be clear.<br>
* implementation - the fully qualified name of a module implementing an authentication provider, followed by ":" and
the class name.<br>
* properties - a dictionary of arguments required to instantiate the authentication provider class. The arguments will
be passed as kwargs to the class' `__init__` method.

According to the above configuration, Cloudify will use two methods to authenticate requests - matching passwords, or,
if that fails, processing a token. <br>
If none of the authenticators succeed - a "401: Unauthorized User" error is returned. <br>

**Password authentication**
<br>
Cloudify's first authenticator is [Flask-SecuREST's password authenticator]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authentication_providers/password.py), which
uses basic HTTP authentication. The request is expected to include an "Authorization" header which contains a base64
encoded [username]:[password] value.
Once decoded, the username is used for retrieving the user object from the userstore, in order to compare the given password
to the stored one.
{{% gsInfo title="Password hash selection" %}}
The default configuration sets `password_hash` to `plaintext`. However, passwords are usually not stored as plaintext.<br>
Set `passowrd_hash` to match the hash scheme used in the selected userstore. <br>
Supported values: 'bcrypt', 'des_crypt', 'pbkdf2_sha256', 'pbkdf2_sha512', 'sha256_crypt' and 'sha512_crypt'.
{{% /gsInfo %}}

**Token authentication**
<br>
Cloudify's second authenticator is [Flask-SecuREST's token authenticator]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authentication_providers/token.py).
The request is expected to include a header named "Authentication-Token", in which the username is stored. The token is
signed and timed, meaning a secret key is required to open it, and it will expire some time after creation.
Once opened, the username found is used to load the user object from the userstore.

It is possible to implement other authentication providers, including providers that do not require accessing a
userstore directly (e.g. oAuth). This is explained later in this document.

<br>
### Token Generation
In order to send a token with each request, the client must first obtain a token.
Tokens can be generated by many systems, and they will work as long as a registered authentication provider knows how
to process them.
Cloudify exposes the */tokens* endpoint to help the user obtain a token easily, even from external systems.
To enable this feature a token generator must be set. Then any GET request to */tokens* will call the token generator
and return a token to the user. <br>
Do note that the request to */tokens* is in itself authenticated.

#### Configuring a Token Generator
Under "auth_token_generator" a single generator is set. Below is the default token generator set in manager-types.yaml:
{{< gsHighlight  yaml  >}}
  security:
    ...
    auth_token_generator:
      implementation: flask_securest.authentication_providers.token:TokenAuthenticator
      properties:
        secret_key: my_secret
        expires_in_seconds: 600
{{< /gsHighlight >}}

The auth_token_generator configuration includes two keys:

* implementation - the fully qualified name of the module implementing a token generator, followed by ":" and the
class name. <br>In the above configuration, `flask_securest.authentication_providers.token` is the module, and
`TokenAuthenticator` is the class name.<br>
* properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method. In the configuration shown above two properties are set:
  * `secret_key` - used to sign the token
  * `expires_in_seconds` - limits the lifetime of a token to 10 minutes. A token older than 10 minutes will be expired
and fail the request.
{{% gsNote title="Secret key selection" %}}
The secret key used by the token generator to sign the token must match the secret key used by the token authenticator
to decrypt it.
{{% /gsNote %}}

<br>
## Authorization
After authenticating the request's user, authorization will take place, if an authorization provider is configured.
An authorization provider is used to verify that the user has the permission to execute the requested method (e.g. *GET*)
on the requested endpoint (e.g. */deployments*).

### Default authorization process
By default, Cloudify uses [Flask-SecuREST's Role-Based Authorization Provider]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authorization_providers/role_based_authorization_provider.py)
to authorize users. Role-based authorization providers evaluate users permissions based on their assigned roles. <br>
A user can have one or more roles, loaded by the [Simple Role Loader]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authorization_providers/role_loaders/simple_role_loader.py);
each role can give the user permissions to access some endpoints methods, and deny others.
<br>
See the configuration sections below for more details on roles and permission assignment.

{{% gsInfo title="Default authorization logic"%}}
In order to be authorized, user access must be explicitly allowed by at least one role **and also not denied by any
role**. <br> If access is allowed by one role but denied by another, the user will not be authorized.
{{% /gsInfo %}}

#### Authorization provider configuration
Under "authorization_provider" a single provider is set. Below is the default authorization configuration, set in
manager-types.yaml:
{{< gsHighlight  yaml  >}}
  security:
    ...
    authorization_provider:
      implementation: flask_securest.authorization_providers.role_based_authorization_provider:RoleBasedAuthorizationProvider
      properties:
        roles_config_file_path: '/opt/manager/roles_config.yaml'
        role_loader:
          implementation: flask_securest.authorization_providers.role_loaders.simple_role_loader:SimpleRoleLoader
{{< /gsHighlight >}}

The authorization_provider configuration includes two keys:

* implementation - the fully qualified name of the module implementing a authorization provider, followed by ":" and the
class name. <br>In the above configuration, `flask_securest.authorization_providers.role_based_authorization_provider`
is the module, and `RoleBasedAuthorizationProvider` is the class name.<br>
* properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method. <br>
In the configuration shown above two properties are set:
  * `roles_config_file_path` - this is the location - on the manager server - of the YAML file that maps roles to permission.
Setting a different path requires modifying the REST creation script accordingly (found at
*"/components/restservice/scripts/create.sh"*, relative to the main manager blueprint file directory).<br>
  * `role_loader` - this is the class that loads the roles of the acting user. By default, the [Simple Role Loader]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authorization_providers/role_loaders/simple_role_loader.py)
is used, which loads roles from the simple userstore, inlined in manager-types.yaml.

<br>
#### Role assignment configuration
The [Simple Role Loader]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authorization_providers/role_loaders/simple_role_loader.py)
load user roles from the simple userstore defined in *manager-types.yaml*.
Here is a possible configuration:
{{< gsHighlight yaml >}}
  userstore_driver:
    implementation: flask_securest.userstores.simple:SimpleUserstore
    properties:
      userstore:
        users:
          - username: alice
            password: alice_password
            groups:
              - cfy_admins
          - username: bob
            password: bob_password
            groups:
              - cfy_deployers
          - username: clair
            password: clair_password
            roles:
              - viewer
          - username: dave
            password: dave_password
        groups:
          - name: cfy_admins
            roles:
              - administrator
          - name: cfy_deployers
              roles:
                - deployer
{{< /gsHighlight >}}

The above userstore configuration defines four users (*alice*, *bob*, *clair* and *dave*) and 2 groups (*cfy_admins* and
*cfy_deployers*).

* alice - a member of the "cfy_admins" group, which is assigned the "administrator" role. This means alice has
the "administrator" role.
* bob - a memeber of the "cfy_deployers" group, which is assigned the "deployer" role. bob therefore has this role.
* clair - not a member of any group, but is personally assigned the "viewer" role.
* dave - not a member of any group, and has no roles assigned to him directly. He there has no permissions at all.

<br>
#### Role permissions
Linking roles to permissions is done in a YAML file - by default this is */resources/rest/roles_config.yaml*,
relative to the main manager blueprint file directory. <br>
The file contains dictionaries, in which the keys are role names and the values are permissions (also dicts).
Permissions are divided to "allow" or "deny", and specify endpoints and their HTTP methods.
This is a possible (not default) configuration:
{{< gsHighlight  yaml  >}}

################################################################################
# The administrator role can access any endpoint, and call any method
################################################################################
administrator:
  allow:
    '*':
      - '*'
################################################################################
# The deployer role can access any endpoint, and call any method except DELETE
################################################################################
deployer:
  allow:
    '*':
      - '*'
  deny:
    '*':
      - DELETE
#############################################################################
# The viewer role can can access any endpoint, but only call the GET method
# it is also denied access to a specific blueprint
#############################################################################
viewer:
  allow:
    '*':
      - GET
  deny:
    '/api/v2/blueprints/blueprint_2':
      - '*'
{{< /gsHighlight >}}

The above configuration defines permissions of three roles:

* administrator - allowed to access any endpoint (the upper '\*') and execute any method (the inner '\*')
* deployer - allowed to access any endpoint and execute any method, but also denied the `DELETE` method on all endpoints.
<br> This practically means this role can execute any method on any endpoint except call `DELETE`.
* viewer - allowed to execute the `GET` method (and only that method) on all endpoints. Additionally, this role is
denied access to `blueprint_2` entirely! all the methods on this endpoint are denied.

<br>
## Auditing
Security operations, such as authentication success or failure and user details, are audited in dedicated log file on
the management server.<br>
The default configuration is:

{{< gsHighlight  yaml  >}}
audit_log_file: /var/log/cloudify/rest-security-audit.log
audit_log_level: INFO
audit_log_file_size_MB: 100
audit_log_files_backup_count: 20
{{< /gsHighlight >}}

- `audit_log_file` - sets the full path to the auditing file on the manager
- `audit_log_level` - modifying the log level will produce less or more elaborate security auditing; valid values are:
CRITICAL, ERROR, WARNING, INFO or DEBUG.
- `audit_log_file_size_MB` - limits the log file size. By default, the file is limited to 100 MB. When the file reaches
that size, it will be renamed with the extension ".1" and a new log file will be created (older files will be renamed
with the extension ".2", ".3" and so forth).
- `audit_log_files_backup_count` - sets the maximum number of old log files to keep. By default this value is set to 20.
That means that up to 20 old log files can be created, after which the oldest file will be removed.

<br>
# Clients

Different clients can be used to send requests to the REST service, and all go through an authentication process.
Here we review what each client requires in order to send a secured request.

### CLI - cfy commands
#### credentials
{{% gsNote title="User credentials must be set before bootstrapping" %}}{{% /gsNote %}}

Cfy commands automatically add the "Authorization" header to each request sent to the manager, containing the username
and password of the current user. Setting the user credentials is done once, by exporting these environment variables:

 - export CLOUDIFY_USERNAME=my_username
 - export CLOUDIFY_PASSWORD=my_password

<br>
#### Client SSL configuration
**Connecting to the manager over SSL**<br>
After bootstrap, and if SSL is enabled, requests sent to the manager must use the 'https' protocol and address port 443.
<br>
The bootstrapping client will already be set accordingly; Other clients that attempt to connect to the secured manager
will need to specify port 443 when calling `cfy use`:
{{< gsHighlight  bash  >}}
cfy use -t <manager-ip-address> --port 443
{{< /gsHighlight >}}

**Verifying the manager's certificate**<br>
By default, the CLI attempts to validate the manager's certificate using public CAs (Certificate Authorities).
The following environment variables can alter that behavior:

 * LOCAL_REST_CERT_FILE - if a local (client-side) copy of the server's certificate should be used for SSL cert
 validation, set it's location on the client machine using this environment variable
To enable this feature, set CLOUDIFY_SSL_CERT to the client's local path to the manager's certificate.
 * CLOUDIFY_SSL_TRUST_ALL - to accept the manager's certificate without validation, set this environment variable to
 True (or any non-empty value)

<br>
### Web UI
Credentials for all requests sent from the Web UI are set at Login. Do note that this client only supports
authentication by username and password. Other authentication methods (e.g. tokens) are currently not supported.

<br>
### Cloudify's REST client
Internally, Cloudify's CLI actually uses Cloudify's [REST client]
(https://github.com/cloudify-cosmo/cloudify-rest-client/tree/3.3-build),
which supports the variety of security configurations discussed in this guide. <br>To use it, create an instance of
[CloudifyClient](https://github.com/cloudify-cosmo/cloudify-rest-client/blob/3.3/cloudify_rest_client/client.py#L231),
initialized with values that match your configuration:

* `host` - The manager's host name or IP address. Default: *'localhost'*
* `port` - The port to send requests to. Default: *80*
* `protocol` - the protocol to send requests on. Default: *'http'*
* `headers` - headers to send with each request. Default: *None*
* `cert` - path to a client copy of the server's certificate (e.g. to validate a self-signed certificate). Default: *None*
* `trust_all` - if set to *True*, SSL certificates will be trusted without validation; if *False* - they will be
validated. Default: *False*


<br>
Here are two usage examples:

* Creating a REST client using credentials, to get a token from a secured manager **without SSL**
{{< gsHighlight  python >}}
from itsdangerous import base64_encode
from cloudify_rest_client import CloudifyClient

headers = {'Authorization': 'Basic ' + base64_encode('MY_USERNAME:MY_PASSWORD')}
rest_client = CloudifyClient(host='1.2.3.4', headers=headers)
token_value = client.tokens.get().value
{{< /gsHighlight>}}

* Creating a REST client using a token, to get the status of a secured manager **with SSL**
{{< gsHighlight  python >}}
from cloudify_rest_client import CloudifyClient

headers = {'Authentication-Token': 'this_is_some_token_value'}
rest_client = CloudifyClient(host='1.2.3.4', port=443, protocol='https', headers=headers)
response = client.manager.get_status()
{{< /gsHighlight>}}




<br>
### External clients
Other REST clients (e.g. cURL) must explicitly add the required header to each request.<br>
For example:

 - Get the server's status, authenticate with username and password:<br>
{{< gsHighlight  bash >}} curl -u 'MY_USERNAME':'MY_PASSWORD' <manager-ip-address>:<port>/api/v2/status{{< /gsHighlight >}}
 - Get a token, authenticate with username and password:<br>
{{< gsHighlight  bash >}} curl -u 'MY_USERNAME':'MY_PASSWORD' <manager-ip-address>:<port>/api/v2/tokens {{< /gsHighlight >}}
 - Get all the blueprints, authenticate with a token:<br>
{{< gsHighlight  bash >}} curl -H 'Authentication-Token:MY_TOKEN' <manager-ip-address>:<port>/api/v2/blueprints {{< /gsHighlight >}}

<br>
# Advanced
## Architecture
Cloudify's security focuses on the REST service, marked in color in this diagram:
![manager architecture]({{< img "guide/security/manager_arch_for_security.png" >}})
<br>
Clients communicate with the manager by sending http(s) requests to the REST service, which in turn processes these
requests and communicates with internal management components (e.g. RabbitMQ, Elasticsearch).<br>

### Secured Request Flow
![full request flow]({{< img "guide/security/full_request_flow.png" >}})

The above diagram illustrates the secured request flow:

1. The client sends a request to *server_ip/endpoint* <br>
2. Nginx receives the request. If SSL is enabled, Nginx presents the server's SSL certificate to the client. <br>
   The client can then validate the certificate. If validation fails - the request fails, as the server cannot be
   trusted. <br>
   If the certificate is validated successfully (or accepted without validation) - request processing
   continues. <br>
3. Is the requested endpoint defined as "secured"? <br>
   Generally, all endpoints are considered secured, which leads to step #4. The only exception is */version*, which is
   open and does not require further access control checks.<br>
4. Attempt to authenticate the request user - is this user valid? is it known to Cloudify? <br>
   Authentication is performed by the registered authentication providers, as explained below. <br>
   If the user is not authenticated - a "401: Unauthorized User" error is returned. <br>
5. Attempt to authorize the request user - is the user allowed to access the endpoint and execute the requested
   method on it (e.g. GET, POST)? <br>
   Authorization is performed by the registered authorization provider, as explained below. If a provider isn't
   registered, this step will be skipped. <br>
   If the user is not authorized - a "401: Unauthorized User" error is returned. <br>
   Otherwise - congrats! the request can reach its endpoint!




<br>
## Customize Security: Use Your Own Implementations
### Implementing custom security components
As shown in previous sections, registering custom python implementations is fairly easy. To replace the default
userstore, token generator, authenticators or authorization provider - simply set the path to the custom class and add
the properties required to instantiate it.
<br>
Implementing security components is just as easy - simply follow the APIs explained below.
<br><br>
#### Userstore driver implementation
A userstore driver is a class that loads user details and returns them as a user object.<br>
A valid userstore implementation is a:

* Python class
* Inherits from [AbstractUserstore](https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/userstores/abstract_userstore.py)
* Implements `get_user(self, identifier)`, which returns a user object containing a dictionary of user details read from the userstore.
  If a matching user is not found, `get_user` should return None.

<br>
#### Authentication provider implementation
An Authentication Provider is a class that performs authentication. It has access to the userstore instance (if a
userstore was configured) and can therefore use it to get user details that are required to perform authentication (e.g.
check if the user account is disabled). <br>
A valid authentication provider implementation is a:

* Python class
* Inherits from [AbstractAuthenticationProvider]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authentication_providers/abstract_authentication_provider.py)
* Implements `authenticate(self, userstore=None)`, which returns a unique user identifier (e.g. username) if
authentication was successful, and raises an exception if it failed. <br>
Exception messages should be informative but not expose confidential user or system details. For example: "Request
authentication header is empty or missing" is OK, while "username jason attempted to use wrong password 123456" reveals
too much information.

<br>
#### Token generator implementation
A token generator is a class that generates tokens and returns them. These tokens should of course be supported by one
of the registered authenticators.<br>
A valid token generator implementation is a:

* Python class
* Implements `generate_auth_token(self)`, which returns a token.

<br>
#### Authorization provider implementation
An authorization provider is a class that performs the authorization logic, after the user authenticity has been verified.
Authorization should evaluate if the acting user is allowed to execute the requested methods (e.g. POST) on the
requested endpoint (e.g. */blueprints*).
A valid authorization provider is a:

* Python class
* Inherits from [AbstractAuthorizationProvider]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authorization_providers/abstract_authorization_provider.py)
* Implements `authorize(self)`, which returns true if the user is authorized, or false otherwise.

<br>
### Packaging, Configuring and Installing Custom Implementations

In order to use custom security components, each component must be structured as a valid python package and installed
on the REST service environment. Installation is performed via the plugins mechanism, which requires the package
location be added to the `plugins` property of the `rest_service` node in manager-types.yaml:

{{< gsHighlight  yaml  >}}
node_types:
  ...
  manager.nodes.RestService:
    ...
    properties:
      ...
      plugins:
        oauth_authentication_provider:
          # see description below
          source: my-security-plugins/oauth-authentication-provider
          # see description below
          install_args: '--pre'

        mysql_userstore:
          # see description below
          source: https://github.com/my-org/mysql-userstore-driver/archive/master.zip
{{< /gsHighlight >}}

The `plugins` section is a dict that contains all plugins that should be installed. The keys of this dict are arbitrary
names that represents the plugin's function. Use meaningful names to make the configuration more readable. In the
example shown above we use `oauth_authentication_provider` and `mysql_userstore`.

* `source` - can be any of the following:
  * A path to the package directory (a valid python package) relative to the main manager blueprint file
  directory (e.g. `my-security-plugins/oauth-authentication-provider`)
  * A URL to the package archive (e.g. `https://github.com/my-org/mysql-userstore-driver/archive/master.zip`)
  * A path/url to a [Wagon](https://github.com/cloudify-cosmo/wagon) package archive. {{% tag %}} 3.3.1 FEATURE {{% /tag %}}
* `install_args` - optional additional arguments to the `pip install` command used to install your plugin.
{{% gsNote title="insalling *.wgn packages" %}}
[Wagon](https://github.com/cloudify-cosmo/wagon) based rest plugin installation requires passing the appropriate `install_args` to the pip command.
Normally, pip arguments for [Wagon](https://github.com/cloudify-cosmo/wagon) based packages would look like so:<br>
`<plugin-name> -r <req_file> --use-wheel --no-index --find-links=wheels/ --pre`
{{% /gsNote %}}

{{% gsNote title="Terminology notice" %}}
When the term *plugin* is used in this section, it should not be confused with operation and workflow plugins.
When we use this term here, we simply mean: custom code that gets installed in the REST service environment. In other
words, plugins here cannot be used as operations and workflows plugins.
{{% /gsNote %}}

<br>
### Examples
<br>
#### LDAP Userstore example
[LDAPUserStore]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/userstores/examples/ldap_userstore.py) is
an example of custom userstore driver that reads users from LDAP. The implementing class inherits from [AbstractUserstore]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/userstores/abstract_userstore.py)
and implements the `get_user` method as required.

The properties to initialize this class should be specified in the manager blueprint as described earlier in [Userstore driver configuration]
(#userstore-driver-configuration), e.g.
{{< gsHighlight  yaml  >}}
userstore_driver:
  implementation: flask_securest.userstores.examples.ldap_userstore:LDAPUserStore
  properties:
    admin_dn: cn=admin,dc=cloudify,dc=org
    admin_password: password
    directory_url: ldap://localhost:389
    root_dn: dc=cloudify,dc=org
    identifying_attribute: uid
    username_attribute: uid
    user_password_attribute: userPassword
    user_email_attribute: mail
    is_active_attribute: is_active
{{< /gsHighlight >}}
The above properties are specific to this example implementation.

In order to use this custom userstore implementation, it must be installed on the REST service as describe in
[Packaging, Configuring and Installing Custom Implementations]
(#packaging-configuring-and-installing-custom-implementations), e.g.:
{{< gsHighlight  yaml  >}}
node_types:
  ...
  manager.nodes.RestService:
    ...
    properties:
      ...
      plugins:
        ldap_userstore:
          source: ldap-userstore
{{< /gsHighlight >}}
where `ldap-userstore` is the path to the package, relative to the manager blueprint's root directory, e.g.:

{{< gsHighlight  yaml  >}}
my_manager_blueprint:
  my-manager-blueprint.yaml
  ldap-userstore:
    ldap_userstore:
      __init__.py
      simple_ldap_userstore.py
    README.md
    setup.py
{{< /gsHighlight >}}

{{% gsNote title="Handling system dependencies" %}}
The LDAP userstore driver example uses [python-ldap](http://www.python-ldap.org/doc/html/ldap.html#module-ldap).

Ideally, we would like to run this command before plugin installation:
{{< gsHighlight  bash >}}
sudo yum install python-devel openldap-devel gcc -y
{{< /gsHighlight >}}

Unfortunately, currently there is no convenient way to specify system dependencies as plugin requirements. This is a
known issue and is intended to be resolved in future versions.

To work around it, edit the REST creation script of the selected manager blueprint
(*"/components/restservice/scripts/create.sh"* relative to the main manager blueprint file directory). In this script, add the above command required to install
[python-ldap](http://www.python-ldap.org/doc/html/ldap.html#module-ldap) just before the REST service installation
command.

Alternatively, modify the relevant manager blueprint to include the installation of the required system dependencies.

{{% /gsNote %}}

#### LDAP authentication provider example: {{% tag %}} 3.3.1 FEATURE {{% /tag %}}
The [cloudify-ldap-plugin](https://github.com/cloudify-cosmo/cloudify-ldap-plugin) provides the ability to authenticate users against any LDAP endpoint.
Configuring the ldap authentication driver:
{{< gsHighlight  yaml  >}}
authentication_providers:
  implementation: authentication.ldap_authentication_provider:LDAPAuthenticationProvider
  name: ldap_authentication_provider
  properties:
    'directory_url': ldap://x.x.x.x:389
{{< /gsHighlight >}}
**Installation**<br>
Since the [cloudify-ldap-plugin](https://github.com/cloudify-cosmo/cloudify-ldap-plugin) is not installed by default when preforming bootstrap, a [custom rest plugin](#packaging-configuring-and-installing-custom-implementations)
must be defined in the manager-blueprint, that would be uploaded and installed upon bootstrap.
Defining the [cloudify-ldap-plugin](https://github.com/cloudify-cosmo/cloudify-ldap-plugin) in the manager blueprint as a rest plugin:
{{< gsHighlight  yaml  >}}
node_types:
  ...
  manager.nodes.RestService:
    ...
    properties:
      ...
      plugins:
        ldap_authentication_provider:
          source: https://github.com/cloudify-cosmo/cloudify-ldap-plugin/archive/1.0.zip
          install_args: '--pre'
{{< /gsHighlight >}}
**System-level requirements**<br>
The LDAP python dependency `python-ldap`, included in the [cloudify-ldap-plugin](https://github.com/cloudify-cosmo/cloudify-ldap-plugin) package, requires system level dependencies
i.e openldap-devel, python-devel, and gcc in order to install.
These system level dependencies should be installed using a userdata script as follows:

* No Wagon package - Userdata script should include `sudo yum install python-devel openldap-devel gcc -y` <br>
* Using Wagon package - Userdata script should only include `sudo yum openldap-devel -y`