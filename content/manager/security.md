---
layout: bt_wiki
title: Security
category: Manager
draft: false
weight: 500

---

Securing access to the manager focuses on the REST service - this is the only access point of clients to the management
server. That is to say, clients communicate with the manager by sending http(s) requests to the REST service, which in
turn processes these requests and communicates with internal management components (e.g. RabbitMQ, Elasticsearch).

![Blueprint Composer topology](images/guide/manager_arch_for_security.png)

When security is enabled, all requests to the manager are authenticated before reaching their endpoint. <br>
For example, when a Web-UI user attempts to upload a new blueprint a request is sent to the REST service's
*"blueprints"* endpoint. The request it will only reach the endpoint if the user is logged in and is authorized to upload
blueprints. Similarly, a user that executes the CLI command "cfy deployments list" triggers a request to execute GET on
the *"deployments"* endpoint, a request that will only be successful if it includes valid credentials, identifying an authorized
user. <br>
Requests generated by other HTTP clients (e.g. curl) must also include correct credentials.

If credentials are missing, invalid or represent an unauthorized user, the request fails with a "401: Unauthorized User" error.



{{% gsNote title="NOTE"%}}
The *“Version”* endpoint doesn't represent a secured resource, and is therefore accessible to all. <br>
Furthermore, Internal requests (originated by Cloudify) bypass the authentication mechanism by using port 8101, which
must be blocked for external access. <br>See the "Advanced" section below for more details.<br>
{{% /gsNote %}}

## Request Flow
![Blueprint Composer topology](images/guide/full_request_flow.png)

The above diagram illustrates the request flow:

1. The client sends a request to *server_ip/endpoint* <br>
2. Nginx receives the request. If SSL is enabled, Nginx presents the server's SSL certificate to the client. <br>
   The client can then validate the certificate. If validation fails - the request fails, as the server cannot be trusted. <br>
   If the certificate is validated successfully (or accepted without validation) - request processing
   continues. <br>
3. Is the requested endpoint defined as "secured"? <br>
   Generally, all endpoints are considered secured, which leads to step #5. <br>
   An exception is the *Version* endpoint, which doesn't represent a secured resource. In that case access control
   checks are not required and the request reaches the endpoint at once. <br>
4. Is this an internal request, sent on port 8101? <br>
   If so - the request will proceed directly to the endpoint. <br>
   Otherwise, the security checks should take place. <br>
5. Attempt to authenticate the request user - is this user valid? is it known to Cloudify? <br>
   Authentication is performed by the registered authentication providers, as explained below. <br>
   If the user is not authenticated - a "401: Unauthorized User" error is returned. <br>
6. Attempt to authorize the request user - is this user allowed to access that endpoint, and perform this actions on it
   (e.g. Get, Post)? <br>
   Authorization is performed by the registered authorization providers, as explained below. If none are registered,
   this step will be skipped. <br>
   If the user is not authorized - a "401: Unauthorized User" error is returned. <br>
   Otherwise - congrats! the request can reach its endpoint!

### Security configuration
The security configuration is done in the manager blueprint. The default settings are specified in
[manager-types.yaml](https://github.com/cloudify-cosmo/cloudify-manager-blueprints/blob/master/types/manager-types.yaml),
in this path:
{{< gsHighlight  yaml  >}}
node_types:
  ...
  cloudify.nodes.MyCloudifyManager:
    ...
    properties:
      ...
      security:
{{< /gsHighlight >}}

The default configuration can be overridden by specific manager blueprints yaml files. Each setting is described in
detail in the following sections.


#### Setting Security On / Off
The first security setting is:

{{< gsHighlight  yaml  >}}
enabled: { get_input: security_enabled }
{{< /gsHighlight >}}

This means security is enabled or disabled according to the input value of `security_enabled`. <br>
In order to activate security set your blueprint's `security_enabled` input to `true` <br>
If set to `false`, all other security settings will be ignored (including SSL)!



# SSL
Using SSL for client-server communication enhances security in two aspects: <br>
1. Privacy - All communications between the client the server are encrypted <br>
2. Trust - When a connection is established, the Cloudify manager presents a signed certificate to the
client. The client can use that certificate to validate the authenticity of the manager. <br>
Client-side certificates are not used.

{{% gsTip title="Using a self-signed certificate" %}}

  A [self-signed certificate](http://en.wikipedia.org/wiki/Self-signed_certificate) can be used. This is a certificate
  that is signed by the manager itself, not by a CA (Certificate Authority).<br>
  In this case, if the client wants to verify the manager's certificate it must hold a copy of that certificate to
  validate against (see [Manager's certificate verification](#ssl-cli-configuration) for client configuration details)

  The following command can be used to create a self-signed certificate:
  {{< gsHighlight  bash  >}}
    openssl req -x509 -nodes -newkey rsa:2048 -keyout key.pem -out certificate.pem -days 365 -batch
  {{< /gsHighlight >}}
  For more information see [The openssl req command](https://www.openssl.org/docs/manmaster/apps/req.html).
{{% /gsTip %}}


### SSL configuration
1. Manager Blueprint<br>
  {{< gsHighlight  yaml  >}}
  security:
    ...
    ssl:
      enabled: { get_input: ssl_enabled }
  {{< /gsHighlight >}}

  This means SSL is enabled or disabled according to the input value of `ssl_enabled`.
  In order to activate the security framework set the input value `security_enabled: true`.
  When enabled, every request to the manager must be sent over https to port 443.<br><br>
2. Required Files<br>
  When running bootstrap, two files should reside in the manager blueprint's directory (on the client machine),
  under *"/resources/ssl"* :<br>
   * server.crt - the signed certificate (this is the public key)<br>
   * server.key - the private key

{{% gsNote title="Creating a valid certificate"%}}
  The SSL verification process requires the common name in the certificate to match the requested URL. Since all
  requests to the manager use the manager's IP address, it is required that the certificate be created with that IP
  address as its common name.
{{% /gsNote %}}


# Access Control

Cloudify's Access Control is comprised of two-steps - authentication and authorization. While authentication is
mandatory when accessing a secured resource, authorization is optional. The sections below details access control
components and their configuration.

# Authentication

## **Userstore Drivers**
While Cloudify does not manage user accounts, some authentication methods may require access to an external userstore -
a repository of users - from which s user object is retrieved. In most cases the userstore is a directory
(e.g. ActiveDirectory) or a database. *Userstore Drivers* are classes that implement access to different userstore types.
Cloudify assumes there is (at most) one userstore from which all users can be loaded.

### Userstore driver configuration
Under "userstore_driver" a single userstore is set. Below is the default userstore configuration, set in
manager-types.yaml:
{{< gsHighlight  yaml  >}}
  security:
    ...
    userstore_driver:
      implementation: flask_securest.userstores.simple:SimpleUserstore
      properties:
        userstore:
          users:
            - username: { get_input: admin_username }
              password: { get_input: admin_password }
              groups:
                - cfy_admins
          groups:
            - name: cfy_admins
              roles:
                - administrator
{{< /gsHighlight >}}

The userstore_driver configuration includes two keys:

* implementation - the fully qualified name of the module implementing a userstore driver, followed by ":" and the
class name. <br>In the above configuration, `flask_securest.userstores.simple` is the module, and `SimpleUserstore` is the
class name. <br>
* properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method.

The default configuration uses [Flask-SecuREST's simple userstore]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/userstores/simple.py).
In this implementation, the userstore is a simple data-structure defined in the manager blueprint and instantiated at
bootstrap. As shown in the configuration above, it contains a single user, and reads its username and password from
input values (`admin_username` and `admin_password` respectively). This implementation is good for demonstrations
purposes. Configuring a "real" userstore driver (e.g. ActiveDirectory) is just as easy, as explained later.

## **Authentication Providers**
Authenticating a request can be done in different ways - matching passwords, binding to a directory service or
delegating the login to an external service (oAuth). Each implementation of an authentication methods is called an
*Authentication Provider* (AKA *Authenticator*). When processing a request, Cloudify calls the registered authenticators
(one or more) in the order of definition in the manager-blueprint. If the first authenticator fails to authenticate the
request - the second will be used, and so on, until successful.<br>
If none of the authenticators succeeded, a "401: Unauthorized User" error is returned.

### Authentication providers configuration
Under "authentication_providers" is a list of all authenticators in the order they should be executed. At least one
authentication provider must be set. <br>
The default configuration set in manager-types.yaml uses two authenticators - `password` and `token`:
{{< gsHighlight  yaml  >}}
  security:
    ...
    authentication_providers:
      - name: password
        implementation: flask_securest.authentication_providers.password:PasswordAuthenticator
        properties:
          password_hash: plaintext
      - name: token
        implementation: flask_securest.authentication_providers.token:TokenAuthenticator
        properties:
          secret_key: my_secret
{{< /gsHighlight >}}

Each Authentication Provider configuration includes these keys:

* name - a unique name describing this authenticator. This name will appear in logs so it should be clear.<br>
* implementation - the fully qualified name of a module implementing an authentication provider, followed by ":" and
the class name.<br>
* properties - a dictionary of arguments required to instantiate the authentication provider class. The arguments will
be passed as kwargs to the class' `__init__` method.

According to the above configuration, Cloudify will use two methods to authenticate requests - matching passwords, or,
if that fails, processing a token. <br>
If none of the authenticators succeed - a "401: Unauthorized User" error is returned. <br>

#### **Password authentication**
Cloudify's first authenticator is [Flask-SecuREST's password authenticator]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authentication_providers/password.py), which
uses basic HTTP authentication. The request is expected to include an "Authorization" header which contains an encoded
[username]:[password] value.
Once decoded, the username is used for retrieving the user object from the userstore, in order to compare the given password
to the stored one.
{{% gsNote title="Note" %}}
The default configuration sets `password_hash` to `plaintext`. However, passwords are usually not stored as plaintext.<br>
Set `passowrd_hash` to match the hash scheme used in the selected userstore. <br>
Supported values: 'bcrypt', 'des_crypt', 'pbkdf2_sha256', 'pbkdf2_sha512', 'sha256_crypt' and 'sha512_crypt'.
{{% /gsNote %}}

#### **Token authentication**
Cloudify's second authenticator is [Flask-SecuREST's token authenticator]
(https://github.com/cloudify-cosmo/flask-securest/blob/0.7/flask_securest/authentication_providers/token.py).
The request is expected to include a header named "Authentication-Token", in which the username is stored. The token is
signed and timed, meaning a secret key is required to open it, and it will expire some time after creation.
Once opened, the username found is used to load the user object from the userstore.

It is possible to implement other authentication providers, including providers that do not require accessing a
userstore directly (e.g. oAuth). This is explained later in this document.


## **Token Generation**
In order to send a token with each request, the client must first obtain a token.
Tokens can be generated by many systems, and they will work as long as a registered authentication provider knows how
to process them.
Cloudify exposes the "/tokens" endpoint to help the user obtain a token easily, even from external systems.
To enable this feature a token generator must be set. Then any GET request to "/tokens" will call the token generator
and return a token to the user. <br>
Do note that the request to "/tokens" is in itself authenticated.

### Configuring a Token Generator
Under "auth_token_generator" a single generator is set. Below is the default token generator set in manager-types.yaml:
{{< gsHighlight  yaml  >}}
  security:
    ...
    auth_token_generator:
      implementation: flask_securest.authentication_providers.token:TokenAuthenticator
      properties:
        secret_key: my_secret
        expires_in_seconds: 600
{{< /gsHighlight >}}

The auth_token_generator configuration includes two keys:

* implementation - the fully qualified name of the module implementing a token generator, followed by ":" and the
class name. <br>In the above configuration, `flask_securest.authentication_providers.token` is the module, and
`TokenAuthenticator` is the class name.<br>
* properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method. In the configuration shown above two properties are set - <br>
"secret_key", used to sign the token, and "expires_in_seconds", which limits the lifetime of a token to 10 minutes.
A token older than 10 minutes will be expired and fail the request.
{{% gsNote title="Note" %}}
The secret key used by the token generator to sign the token must match the secret key used by the token authenticator
to un-sign it.
{{% /gsNote %}}

## **Authorization**
After authenticating the request's user, authorization will take place, if an authorization provider is configured.
An authorization provider is used to verify that the user has the permission to execute the requested method (e.g. *GET*)
on the requested endpoint (e.g. *deployments*).

### Default authorization process
By default, Cloudify uses [Flask-SecuREST's Role-Based Authorization Provider]
(https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/authorization_providers/role_based_authorization_provider.py)
to authorize users. Role-based authorization providers evaluate users permissions based on their assigned roles. <br>
A user can have one or more roles, loaded by the [Simple Role Loader]
(https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/authorization_providers/role_loaders/simple_role_loader.py);
each role can give the user permissions to access some endpoints methods, and deny others.
<br>
See the configuration sections below for more details on roles and permission assignment.
{{% gsNote title="default authorization provider"%}}
In order to be authorized, a user must be allowed access to the requested endpoint method by at least one assigned role
**and also not denied them by any role**
{{% /gsNote %}}

### Authorization provider configuration
Under "authorization_provider" a single provider is set. Below is the default authorization configuration, set in
manager-types.yaml:
{{< gsHighlight  yaml  >}}
  security:
    ...
    authorization_provider:
      implementation: flask_securest.authorization_providers.role_based_authorization_provider:RoleBasedAuthorizationProvider
      properties:
        roles_config_file_path: '/opt/manager/roles_config.yaml'
        role_loader:
          implementation: flask_securest.authorization_providers.role_loaders.simple_role_loader:SimpleRoleLoader
{{< /gsHighlight >}}

The authorization_provider configuration includes two keys:

* implementation - the fully qualified name of the module implementing a authorization provider, followed by ":" and the
class name. <br>In the above configuration, `flask_securest.authorization_providers.role_based_authorization_provider`
is the module, and `RoleBasedAuthorizationProvider` is the class name.<br>
* properties - a dictionary of arguments required to instantiate the implementing class. The arguments will be passed as
kwargs to the class' `__init__` method. <br>
In the configuration shown above two properties are set - <br>
`roles_config_file_path` - this is the location of the file mapping roles to permission, on the manager itself. If you
changes this value, you will have to modify the manager blueprint REST creation script accordingly. The script is found
at *"/components/restservice/scripts/create.sh"*.<br>
`role_loader` - this is the class that loads the roles of the acting user. By default, the SimpleRoleLoader is used,
which loads roles from the simple userstore found in manager-types.yaml.


### Role assignment configuration
The [Simple Role Loader]
(https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/authorization_providers/role_loaders/simple_role_loader.py)
load user roles from the simple userstore defined in *manager-types.yaml*.
Here is a possible configuration:
{{< gsHighlight yaml >}}
  userstore_driver:
    implementation: flask_securest.userstores.simple:SimpleUserstore
    properties:
      userstore:
        users:
          - username: alice
            password: alice_password
            groups:
              - cfy_admins
          - username: bob
            password: bob_password
            groups:
              - cfy_deployers
          - username: clair
            password: clair_password
            roles:
              - viewer
          - username: dave
            password: dave_password
        groups:
          - name: cfy_admins
            roles:
              - administrator
          - name: cfy_deployers
              roles:
                - deployer
{{< /gsHighlight >}}

The above userstore configuration defines four users (*alice*, *bob*, *clair* and *dave*) and 2 groups (*cfy_admins* and
*cfy_deployers*).

* alice - alice is a member of the group "cfy_admins", which is assigned the role "administrator". This means alice has
the "administrator" role.
* bob - bob is a memeber of the group "cfy_deployers", which is assigned the role "deployer". bob there has this role.
* clair - clair is not a member of any group, but is assigned the role "viewer" directly.
* dave - dave is not a member of any group, and has no roles assigned to him directly. He there has no permissions at all.


### Role permissions
Linking roles to permissions is done a YAML file - by default this is */resources/rest/roles_config.yaml*,
relative to the [main manager blueprint file](reference-terminology.html#main-blueprint-file) directory. <br>
The file contains dictionaries, in which the leys are role names and the values are permissions (also dicts).
Permissions are divided to "allow" or "deny", and specify endpoints and their HTTP methods.
This is a possible (not default) configuration:
{{< gsHighlight  yaml  >}}

################################################################################
# The administrator role can access any endpoint, and call any method
################################################################################
administrator:
  allow:
    '*':
      - '*'
################################################################################
# The deployer role can access any endpoint, and call any method except DELETE
################################################################################
deployer:
  allow:
    '*':
      - '*'
  deny:
    '*':
      - DELETE
#############################################################################
# The viewer role can can access any endpoint, but only call the GET method
# it is also denied access to specific resources
#############################################################################
viewer:
  allow:
    '*':
      - GET
  deny:
    '/api/v2/blueprints/blueprint_2':
      - '*'
{{< /gsHighlight >}}

The above configuration defines permissions of three roles:

* administrator - allowed to access any endpoint (the upper '\*') and execute any method (the inner '\*')
* deployer - allowed to access any endpoint and execute any method, but also denied the *DELETE* method on all endpoints.
<br> This practically means this role can execute any method on any endpoint except call *DELETE*.
* viewer - allowed to execute the *GET* method (and only that method) on all endpoints. Additionally, this role is
denied access to blueprint_2 entirely! all the methods on this endpoint are denied.



## **Logging**
Security operations, such as authentication success or failure and user details, are audited in dedicated log file on
the management container.
The default configuration is:

{{< gsHighlight  yaml  >}}
audit_log_file: /var/log/cloudify/rest-security-audit.log
audit_log_level: INFO
log_file_size_MB: 100
log_files_backup_count: 20
{{< /gsHighlight >}}

- Modifying the log level will produce less or more elaborate security auditing; The acceptable values are:
CRITICAL, ERROR, WARNING, INFO or DEBUG.
- audit_log_file_size_MB - limits the log file size. By default, the file is limited to 100 MB. When the file reaches
that size, it will be renamed with the extension ".1" and a new log file will be created.
- audit_log_files_backup_count - sets the maximum number of old log files to keep. By default this value is set to 20.
That means that up to 20 old log files can be created, after which the oldest file will be removed.


# Clients

Different clients can be used to send requests to the REST service, and all go through an authentication process.
Here we review what each client requires in order to send a secured request.

## **Cloudify CLI** - cfy commands
### credentials
{{% gsNote title="Important" %}}
You must set user credentials prior to bootstrapping!
{{% /gsNote %}}

Cfy commands automatically add an "Authorization" header to each request sent to the manager, containing the username
and password of the current user. <br>
Setting the user credentials is done once, by exporting these environment variables:

 - CLOUDIFY_USERNAME
 - CLOUDIFY_PASSWORD


### SSL CLI configuration
#### **Connecting to the manager over SSL**
After bootstrap, requests sent to the manager must use port 443 and the 'https' protocol. <br>
The `cfy use` command requires specifying the port option to be 443:
{{< gsHighlight  bash  >}}
cfy use -t <manager-ip-address> --port 443
{{< /gsHighlight >}}

#### **Verifying the manager's certificate**
By default, the cli will attempt to validate the manager's certificate using public CAs (Certificate Authorities).
The following environment variable can alter that behavior:

 * `CLOUDIFY_SSL_CERT` - If public CAs should not be used for certificate validation (e.g. when working offline or
 validating a self-singed certificate), <br>a client-copy of the server's certificate can be used instead.
To enable this feature set CLOUDIFY_SSL_CERT to the client's local path to the manager's public certificate.
 * `CLOUDIFY_SSL_TRUST_ALL` - set this environment variaable True (or any non-empty value) to accept the manager's
 certificate without validation.


## **Web UI**
{{% gsNote title="The Web UI is only available in the premium edition" %}}
{{% /gsNote %}}


Credentials for all requests sent from the Web UI are set at Login.<br>
Do note that this client only supports authentication with username and password. Tokens or other authenticators are
currently not supported.


## **Other REST Clients**
other REST clients (e.g. cURL) must explicitly add credentials to each request.<br>
For example:

 - Get the server status, authenticate with username and password:<br>
{{< gsHighlight  bash >}} curl -u 'MY_USERNAME':'MY_PASSWORD' <manager-ip-address>:<port>/api/v2/status{{< /gsHighlight >}}
 - Get a token, authenticate with username and password:<br>
{{< gsHighlight  bash >}} curl -u 'MY_USERNAME':'MY_PASSWORD' <manager-ip-address>:<port>/api/v2/tokens {{< /gsHighlight >}}
 - Get all the blueprints, authenticate with a token:<br>
{{< gsHighlight  bash >}} curl -H 'Authentication-Token:MY_TOKEN' <manager-ip-address>:<port>/api/v2/blueprints {{< /gsHighlight >}}


# Behind the Scenes / Advanced


## **Internal communication between the Cloudify manager and other Cloudify components**

Currently, communication between Cloudify agents and the manager or within the manager itself does not go through
authentication or authorization. <br>
Instead, these requests are sent over port 8101, used by the REST service to identify them as internal and allow them to
proceed directly to the requested endpoint.

The usage of this port, however, must be restricted to components on the same subnet as the Cloudify manager alone.
This is done using specific security group rules, which are set up during bootstrap (for example, see [this rule in the
Openstack manager blueprint](https://github.com/cloudify-cosmo/cloudify-manager-blueprints/blob/master/openstack/openstack-manager-blueprint.yaml#L206)).
It is therefore impossible to bypass the security mechanisms from outside the manager's internal network by making REST
calls directly to the 8101 port.

In future versions, all communications from and to the Cloudify manager will utilize the security mechanisms, including communication with any of Cloudify's internal components, at which time, the bypass port 8101 will be removed.


# Customize Security - Use Your Own Userstore, Authentication and Authorization Providers

## **Implementing Custom Security Components**
As shown if previous sections, it is fairly easy to register custom python implementation to replace the default userstore,
token generators, authentication or authorization providers - simple set the path to the implementing class and add the
properties required to instantiate it.
<br>
Implementing security components is just as easy - simply follow these APIs explained below.

### Userstore driver implementation
A userstore driver is simply a class that loads user details and returns them as a user object.<br>
A valid userstore implementation is a:

* Python class
* Inherits from [AbstractUserstore](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/userstores/abstract_userstore.py)
* Implements `get_user(self, identifier)`, which returns a user object containing a dictionary of user details read from the userstore.
  If a matching user is not found, `get_user` should return None.


### Authentication provider implementation
An Authentication Provider is a class that performs authentication. It has access to the userstore instance (if a
userstore was configured) and can therefore use it to get user details that are required to perform authentication (e.g.
check if the user account is disabled). <br>
A valid authentication provider implementation is a:

* Python class
* Inherits from [AbstractAuthenticationProvider]
(https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/authentication_providers/abstract_authentication_provider.py)
* Implements `authenticate(self, userstore=None)`, which returns a unique user identifier (e.g. username) if
authentication was successful, and raises an exception if it failed. <br>
Exception messages should be informative but not
expose confidential user or system details. For example: "Request authentication header is empty or missing" is OK,
while "username jason attempted to use wrong password 123456" reveals too much information.

### Token generator implementation
A token generator is simply a class that generates tokens and returns them. These tokens should of course be supported
by one of the registered authenticators.<br>
A valid token generator implementation is a:

* Python class
* Implements `generate_auth_token(self)`, which returns a token.

### Authorization provider implementation
An authorization provider is a class that performs the authorization logic, after the user authenticity has been verified.
Authorization should evaluate if the acting user is allowed to execute the requested methods (e.g. POST) on the
requested endpoint (e.g. blueprints).
A valid authorization provider is a:

* Python class
* Inherits from [AbstractAuthorizationProvider]
(https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/authorization_providers/abstract_authorization_provider.py)
* Implements `authorize(self)`, which returns true if the user is authorized, or false otherwise.

## **Packaging, Configuring and Installing Custom Implementations**

In order to use these custom security components, the implementing packages must be installed on the manager's REST
environment. The custom component must be structured as a valid python package. <br>
Installation will be performed by the plugins mechanism, which requires the package location be added to the `plugins`
property of the `rest_service` node in manager-types.yaml:

{{< gsHighlight  yaml  >}}
node_types:
  ...
  manager.nodes.RestService:
    ...
    properties:
      ...
      plugins:
        my_authentication_provider:
          # see description below
          source: my-extensions/simple-authentication-provider
          # see description below
          install_args: '--pre'

        my_userstore:
          # see description below
          source: https://github.com/my-org/my-auth-provider/archive/master.zip
{{< /gsHighlight >}}

The `plugins` section is a dict that contains all plugins that should be installed.<br>
The keys of this dict are arbitrary names. Use meaningful names to make the configuration more readable. In this example
we use `my_authentication_provider` and `my_userstore`.

* `source` - can be any of the following:
  * A path to the package directory (a valid python package) relative to the [main manager blueprint file](reference-terminology.html#main-blueprint-file)
  directory (e.g. `my-extensions/simple-authentication-provider`)
  * A URL to the package archive (e.g. `https://github.com/my-org/my-auth-provider/archive/master.zip`)
* `install_args` - optional additional arguments to the `pip install` command used to install your plugin.


{{% gsNote title="Note" %}}
When the term *plugin* is used in this section, it should not be confused with operation and workflow plugins.
When we use this term here, we simply mean: custom code that gets installed in the rest service environment. In other
words, plugins here cannot be used as operations and workflows plugins.
{{% /gsNote %}}


## **Examples**

### LDAP UserStore Example:
  An example for a userstore class - [LDAPUserStore](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/userstores/examples/ldap_userstore.py).<br>
  This class inherits from [AbstractUserstore](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/userstores/abstract_userstore.py) and implements the `get_user` method as required.

  The properties to initialize this class should be specified in the manager blueprint as described earlier in [Configuring a Userstore](#configuring-a-userstore), e.g.
  {{< gsHighlight  yaml  >}}
  userstore_driver:
    implementation: flask_securest.userstores.examples.ldap_userstore:LDAPUserStore
    properties:
      admin_dn: cn=admin,dc=cloudify,dc=org
      admin_password: password
      directory_url: ldap://localhost:389
      root_dn: dc=cloudify,dc=org
      identifying_attribute: uid
      username_attribute: uid
      user_password_attribute: userPassword
      user_email_attribute: mail
      is_active_attribute: is_active
  {{< /gsHighlight >}}
  The above properties are specific to this example implementation.

  In order to use this custom userstore, the implementation of the LDAPUserStore class should be installed on the rest service as describe in [Packaging, Configuring and Installing Custom Implementations](#packaging-configuring-and-installing-custom-implementations), e.g.
  {{< gsHighlight  yaml  >}}
  node_templates:
    ...
    rest_service:
      ...
      properties:
        ...
        plugins:
          ldap_userstore:
            source: userstores
  {{< /gsHighlight >}}
  where userstores is the path to the userstores directory, relative to the manager blueprint's directory, for example:

  {{< gsHighlight  yaml  >}}

  my_app:
    userstores:
      ldap_userstores:
        __init__.py
        simple_ldap_userstore.py
      README.md
      setup.py
    my-manager-blueprint.yaml

  {{< /gsHighlight >}}

  {{% gsNote title="Note" %}}
  This ldap userstore example uses the [Python LDAP](http://www.python-ldap.org/doc/html/ldap.html#module-ldap) and the [Flask-SecuREST](https://github.com/cloudify-cosmo/flask-securest) modules.<br>
  To install python-ldap successfully, the following development libraries are needed (package names taken from ubuntu environment):
    {{< gsHighlight  bash >}}
    sudo apt-get install -y python-dev libldap2-dev libsasl2-dev libssl-dev
    {{< /gsHighlight >}}

  In order for the plugin installation to be successfull, these packages must be installed.<br>
  Unfortunately, currently there is no convenient way for specifying system dependencies as plugin requirements.<br>
  This is a known issue and is intended to be solved in Cloudify 3.3.<br>
  To work around it, one option is to supply a custom cloudify manager docker image with the above packages installed (see [Generate a custom Cloudify manager image](https://github.com/cloudify-cosmo/cloudify-packager/blob/master/README.md#generate-a-custom-cloudify-manager-image))<br>
  Another work-around is to add the installation command to the setup.py file, for example:

{{< gsHighlight  yaml >}}
import os
from setuptools import setup

os.system('sudo apt-get install -y libldap2-dev libsasl2-dev')

setup(
  name='userstores',
  version='0.1',
  url='https://github.com/cloudify-cosmo/flask-securest/userstores/examples',
  license='LICENSE',
  author='cosmo-admin',
  author_email='cosmo-admin@gigaspaces.com',
  description='userstore examples',
  packages=[
    'ldap_userstores'
  ],
  install_requires=[
  'python-ldap>=2.4.19',
    'Flask-SecuREST>=0.6'
  ]
)
{{< /gsHighlight >}}

{{% /gsNote %}}


### Password Based Authentication Provider Example:
  An example for authentication provider - [PasswordAuthenticator](https://github.com/cloudify-cosmo/flask-securest/blob/master/flask_securest/authentication_providers/password.py)
  This class implements an authentication provider based on password authentication.
  The `authenticate` method compares the password given from the user store (using the `get_user()` method) with the one recieved from the user (on the request).

  The properties to initialize this class should be specified in the manager blueprint as described earlier in [Configuring Authentication Providers](#configuring-authentication-providers).<br>


